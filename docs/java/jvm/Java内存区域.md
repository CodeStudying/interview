
# Java内存区域

## 1. 概述

Java虚拟机定义了在执行程序时使用的各种运行时数据区域。其中一部分数据区域在Java虚拟机启动时创建，只有在Java虚拟机退出时才被销毁。其他数据区域在创建线程时创建，在线程退出时销毁。

## 2.运行时数据区域

### 2.1 程序计数器

程序计数器(Program Counter Register)是指向当前线程正在执行的字节码指令的地址或行号。

Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，同一时刻一个处理器只能执行一条线程中的指令。为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器独立存储互不影响。

如果当前线程正在执行的是Java方法，该PC寄存器记录当前正在执行的Java虚拟机指令的地址；如果当前线程正在执行的方法是Native的，则Java虚拟机PC寄存器的值是undefined。

### 2.2 Java虚拟机栈

Java虚拟机栈(Java Virtual Machine Stacks)的生命周期与线程相同，虚拟机栈的栈元素是栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。当有一个方法被调用时，代表这个方法的栈帧入栈；当这个方法返回时，其栈帧出栈。因此，虚拟机栈中栈帧的入栈顺序就是方法调用顺序。

<div align="center"> <img src="/docs/pics/jvm_runtimeData_frame.png" width="400px"> </div>

局部变量表存放了编译期可知的各种基本数据类型、对象引用以及returnAddress类型。JVM通过索引访问局部变量，访问索引从0开始到小于局部变量表最大的Slot长度。long或double二进制位数是64bit类型的值占用两个连续的局部变量(如果需要访问一个64bit的局部变量值时，只需要使用前一个索引即可)，其余数据类型只占用1个。JVM使用局部变量表来完成方法调用时的参数传递，当类方法被调用时，所有参数从局部变量0开始传递；当实例方法被调用时，访问索引为0通常存储的是与被调用实例方法相对应的对象引用，而后续的其他方法参数会按照顺序从局部变量表中索引为1的位置开始传递。

Java 虚拟机栈规定了两种异常：

- 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。
- 如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。


## 参考

- <https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5>
- 《深入理解Java虚拟机：JVM高级特性与最佳实践》周志明,机械工业出版社
- [http://liwenkun.me/2017/03/06/explore-java-vm-stack/](http://liwenkun.me/2017/03/06/explore-java-vm-stack/)
